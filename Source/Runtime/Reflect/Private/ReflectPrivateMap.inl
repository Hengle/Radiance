// ReflectPrivateMap.inl
// Copyright (c) 2010 Sunside Inc., All Rights Reserved
// Author: Mike Songy
// See Radiance/LICENSE for licensing terms.

#include <sstream>

//////////////////////////////////////////////////////////////////////////////////////////
// operator new()
//////////////////////////////////////////////////////////////////////////////////////////

inline void *operator new(size_t size, const reflect::Class *type, void *location)
{
	return location;
}

//////////////////////////////////////////////////////////////////////////////////////////
// operator delete()
//////////////////////////////////////////////////////////////////////////////////////////

inline void operator delete(void *p, const reflect::Class *type, void *location)
{
}

//////////////////////////////////////////////////////////////////////////////////////////
// Begin namespace reflect::details
//////////////////////////////////////////////////////////////////////////////////////////


namespace reflect {
namespace details {

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::GetInstance<Predicate, T, TTuple, I>::Execute()
//////////////////////////////////////////////////////////////////////////////////////////

template <bool Predicate, typename T, typename TTuple, int I>
inline void GetInstance<Predicate, T, TTuple, I>::Execute(const T **dest, const TTuple &src)
{
	dest[I - 1] = src.Head().template Instance<I - 1>();
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::GetInstance<false, T, TTuple, I>::Execute()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T, typename TTuple, int I>
inline void GetInstance<false, T, TTuple, I>::Execute(const T **dest, const TTuple &src)
{
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::TypeBase::TypeBase<TTraits, IsConst>()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename TTraits, bool IsConst>
inline TypeBase<TTraits, IsConst>::TypeBase(CLASSDESCRIPTOR descriptor) :
Class(
	descriptor.attributes,
	descriptor.name,
	descriptor.size,
	descriptor.alignment,
	descriptor.supers,
	descriptor.members.members,
	descriptor.members.staticMembers,
	descriptor.members.staticConstants,
	descriptor.constructors,
	descriptor.methods.methods,
	descriptor.methods.constMethods,
	descriptor.methods.staticMethods,
	descriptor.dtor
)
{
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::TypeBase::TypeBase<TTraits, IsConst>()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename TTraits>
inline TypeBase<TTraits, true>::TypeBase(CLASSDESCRIPTOR descriptor) :
Class(
	descriptor.attributes,
	descriptor.name,
	descriptor.size,
	descriptor.alignment,
	descriptor.supers,
	descriptor.members.members,
	descriptor.members.staticMembers,
	descriptor.members.staticConstants,
	descriptor.constructors,
	NULL,
	descriptor.methods.constMethods,
	descriptor.methods.staticMethods,
	descriptor.dtor
)
{
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::ClassType<TRAITS_TYPE, false>::~ClassType()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename TRAITS_TYPE, bool IsConst>
inline ClassType<TRAITS_TYPE, IsConst>::~ClassType()
{
	::reflect::details::ClassList::Remove(*this);
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::Type<TRAITS_TYPE, false>::ConstType()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename TRAITS_TYPE, bool IsConst>
const Class *ClassType<TRAITS_TYPE, IsConst>::ConstType() const
{
	return ::reflect::Type<
		typename ::meta::AddConst<TYPE>::Type
	>();
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::ClassType<TRAITS_TYPE, false>::ClassType()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename TRAITS_TYPE, bool IsConst>
inline ClassType<TRAITS_TYPE, IsConst>::ClassType() :
TypeBase<TRAITS_TYPE, IsConst>(TRAITS_TYPE::Descriptor())
{
	::reflect::details::ClassList::Insert(*this);
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::ClassType<TRAITS_TYPE, true>::~ClassType()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename TRAITS_TYPE>
inline ClassType<TRAITS_TYPE, true>::~ClassType()
{
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::ClassType<TRAITS_TYPE, true>::ConstType()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename TRAITS_TYPE>
const Class *ClassType<TRAITS_TYPE, true>::ConstType() const
{
	return this;
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::ClassType<TRAITS_TYPE, true>::ClassType()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename TRAITS_TYPE>
inline ClassType<TRAITS_TYPE, true>::ClassType() :
TypeBase<TRAITS_TYPE, true>(TRAITS_TYPE::Descriptor())
{
}

} // details
} // reflect

