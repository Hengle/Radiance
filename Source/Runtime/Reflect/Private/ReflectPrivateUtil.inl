// ReflectPrivateUtil.inl
// Copyright (c) 2010 Sunside Inc., All Rights Reserved
// Author: Mike Songy
// See Radiance/LICENSE for licensing terms.

namespace reflect {
namespace details {

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::ConstPointerArray<T>::ConstPointerArray()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline ConstPointerArray<T>::ConstPointerArray() :
m_array(NULL),
m_length(0)
{
}

template <typename T>
inline ConstPointerArray<T>::ConstPointerArray(const T **a) :
m_array(a),
m_length(0)
{
	if (NULL != m_array)
	{
		while (NULL != m_array[m_length]) { ++m_length; }
	}
}

template <typename T>
inline ConstPointerArray<T>::ConstPointerArray(const ConstPointerArray<T> &a) :
m_array(a.m_array),
m_length(a.m_length)
{
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::ConstPointerArray<T>::~ConstPointerArray()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline ConstPointerArray<T>::~ConstPointerArray()
{
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::ConstPointerArray<T>::Length()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline int ConstPointerArray<T>::Length() const
{
	RAD_ASSERT(m_length >= 0);
	return m_length;
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::ConstPointerArray<T>::operator[]()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline const T *ConstPointerArray<T>::operator[](int i) const
{
	RAD_ASSERT(NULL != m_array);
	RAD_ASSERT(m_length > 0);
	RAD_ASSERT(i >= 0);
	RAD_ASSERT(i < m_length);
	return m_array[i];
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::ConstPointerArray<T>::operator=()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline ConstPointerArray<T> &ConstPointerArray<T>::operator=(const ConstPointerArray<T> &a)
{
	m_array = a.m_array;
	m_length = a.m_length;
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::Name::Name()
//////////////////////////////////////////////////////////////////////////////////////////

inline Name::Name() :
m_name(NULL),
m_wname(NULL)
{
}

inline Name::Name(
	const char    *name,
	const wchar_t *wname
) :
m_name(name),
m_wname(wname)
{
}

inline Name::Name(const Name &n) :
m_name(n.m_name),
m_wname(n.m_wname)
{
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::Name::~Name()
//////////////////////////////////////////////////////////////////////////////////////////

inline Name::~Name()
{
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::Name::As<char>()
//////////////////////////////////////////////////////////////////////////////////////////

template <>
inline const char *Name::As<char>() const
{
	RAD_ASSERT(NULL != m_name);
	return m_name;
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::Name::As<unsigned char>()
//////////////////////////////////////////////////////////////////////////////////////////

template <>
inline const unsigned char *Name::As<unsigned char>() const
{
	RAD_ASSERT(NULL != m_name);
	return (const unsigned char *)m_name;
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::Name::As<wchar_t>()
//////////////////////////////////////////////////////////////////////////////////////////

template <>
inline const wchar_t *Name::As<wchar_t>() const
{
	RAD_ASSERT(NULL != m_wname);
	return m_wname;
}

//////////////////////////////////////////////////////////////////////////////////////////
// reflect::details::Name::operator=()
//////////////////////////////////////////////////////////////////////////////////////////

inline Name &Name::operator=(const Name &n)
{
	m_name = n.m_name;
	m_wname = n.m_wname;
	return *this;
}

} // details
} // reflect

