// LWNodeList.inl
// Inherited list (with no vtable) inline implementation.
// Copyright (c) 2010 Sunside Inc., All Rights Reserved
// Author: Joe Riedel
// See Radiance/LICENSE for licensing terms.

//////////////////////////////////////////////////////////////////////////////////////////
// Begin namespace container
//////////////////////////////////////////////////////////////////////////////////////////


namespace container {

//////////////////////////////////////////////////////////////////////////////////////////
//
// LWNodeList
//
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////

//
// Construction
//

//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::LWNodeList()
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::LWNodeList()
{
#if defined(RAD_OPT_DEBUG)
	m_id = MAGIC_ID;
#endif

	m_size = 0;
	m_head = m_tail = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::~LWNodeList()
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::~LWNodeList()
{
#if defined(RAD_OPT_DEBUG)
	AssertValid();
	RAD_ASSERT_MSG(m_head == 0 && m_tail == 0, "Attempting to destruct an active list!");
#endif
}

//////////////////////////////////////////////////////////////////////////////////////////

//
// Insertion/Removal functions.
//

//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::InsertFirst()
//////////////////////////////////////////////////////////////////////////////////////////

inline void LWNodeList::InsertFirst(Node* node)
{
	InsertBefore(m_head, node);
	RAD_ASSERT(m_head == node);
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::InsertLast()
//////////////////////////////////////////////////////////////////////////////////////////

inline void LWNodeList::InsertLast(Node* node)
{
	InsertAfter(m_tail, node);
	RAD_ASSERT(m_tail == node);
}


//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::RemoveFirst()
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::Node* LWNodeList::RemoveFirst()
{
	Node* n = First();

	RAD_ASSERT(n);

	Remove(n);

	return n;
}


//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::RemoveLast()
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::Node* LWNodeList::RemoveLast()
{
	Node* n = Last();

	RAD_ASSERT(n);

	Remove(n);

	return n;
}



//////////////////////////////////////////////////////////////////////////////////////////

//
// First/Last
//

//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::First()
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::Node* LWNodeList::First()
{
	return m_head;
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::First() const
//////////////////////////////////////////////////////////////////////////////////////////

inline const LWNodeList::Node* LWNodeList::First() const
{
	return m_head;
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::Last()
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::Node* LWNodeList::Last()
{
	return m_tail;
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::Last() const
//////////////////////////////////////////////////////////////////////////////////////////

inline const LWNodeList::Node* LWNodeList::Last() const
{
	return m_tail;
}

//////////////////////////////////////////////////////////////////////////////////////////

//
// Utilization
//

//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::Clear()
//////////////////////////////////////////////////////////////////////////////////////////

inline void LWNodeList::Clear()
{
#if defined(RAD_OPT_DEBUG)
	while (First() != 0) { Remove(First()); }
	RAD_ASSERT(m_head == 0 && m_tail == 0 && m_size == 0);
#else
	m_head = 0;
	m_tail = 0;
	m_size = 0;
#endif
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::Size()
//////////////////////////////////////////////////////////////////////////////////////////

inline UReg LWNodeList::Size() const
{
	return m_size;
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::IsEmpty()
//////////////////////////////////////////////////////////////////////////////////////////

inline bool LWNodeList::IsEmpty() const
{
	return Size() == 0;
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::Begin() const
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::Iterator LWNodeList::Begin() const
{
	BaseIterator base;
	base.m_node = m_head;
	base.m_ofs = 0;
	return Iterator(base);
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::BeginAt() const
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::Iterator LWNodeList::BeginAt(const Node* node) const
{
	RAD_ASSERT((&node) != 0);
	BaseIterator base;
	base.m_node = const_cast<Node*>(node);
	base.m_ofs = 0;
	return Iterator(base);
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::End() const
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::Iterator LWNodeList::End() const
{
	BaseIterator base;
	base.m_node = m_tail;

	if (m_tail)
		base.m_ofs = Size() - 1;
	else
		base.m_ofs = 0;

	return Iterator(base);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// LWNodeList::BaseIterator
//
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::BaseIterator::BaseIterator()
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::BaseIterator::BaseIterator()
{
	m_node = 0;
	m_ofs = 0;
	m_list = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::BaseIterator::~BaseIterator()
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::BaseIterator::~BaseIterator()
{
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::BaseIterator::Next()
//////////////////////////////////////////////////////////////////////////////////////////

inline void LWNodeList::BaseIterator::Next()
{
	RAD_ASSERT(m_node);
	m_ofs++;
	m_node = m_node->Next();
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::BaseIterator::Prev()
//////////////////////////////////////////////////////////////////////////////////////////

inline void LWNodeList::BaseIterator::Prev()
{
	RAD_ASSERT(m_node);
	m_ofs--;
	m_node = m_node->Prev();
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::BaseIterator::Value() const
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::Node* const& LWNodeList::BaseIterator::Value() const
{
	RAD_ASSERT(m_node);
	return m_node;
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::BaseIterator::IsEqual()
//////////////////////////////////////////////////////////////////////////////////////////

inline bool LWNodeList::BaseIterator::IsEqual(const BaseIterator& iterator) const
{
	return (m_node == iterator.m_node);
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::BaseIterator::IsEqual()
//////////////////////////////////////////////////////////////////////////////////////////

inline bool LWNodeList::BaseIterator::IsGreater(const BaseIterator& iterator) const
{
	return (m_ofs > iterator.m_ofs);
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::BaseIterator::IsEqual()
//////////////////////////////////////////////////////////////////////////////////////////

inline bool LWNodeList::BaseIterator::IsLess(const BaseIterator& iterator) const
{
	return (m_ofs < iterator.m_ofs);
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::BaseIterator::IsValid()
//////////////////////////////////////////////////////////////////////////////////////////

inline bool LWNodeList::BaseIterator::IsValid() const
{
	return (m_node != 0);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// LWNodeList::Node
//
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::Node::Node()
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::Node::Node()
{
#if defined(RAD_OPT_DEBUG)
	m_id = MAGIC_ID;
	m_list = 0;
#endif
	m_next = m_prev = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::Node::Node()
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::Node::Node(const Node& n)
{
#if defined(RAD_OPT_DEBUG)
	m_id = MAGIC_ID;
	m_list = 0;
#endif
	m_next = m_prev = 0;
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::Node::~Node()
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::Node::~Node()
{
#if defined(RAD_OPT_DEBUG)
	AssertValid();
	RAD_ASSERT_MSG(m_next == 0 && m_prev == 0, "Attempting to destruct an object that is still in a list!");
#endif
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::Node::AssertValid()
//////////////////////////////////////////////////////////////////////////////////////////

#if defined(RAD_OPT_DEBUG)
inline void LWNodeList::Node::AssertValid() const
{
	RAD_ASSERT_MSG(m_id == MAGIC_ID, "Corrupted list node!");
}
#endif

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::Node::Next()
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::Node* LWNodeList::Node::Next()
{
#if defined(RAD_OPT_DEBUG)
	AssertValid();
#endif
	return m_next;
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::Node::Next() const
//////////////////////////////////////////////////////////////////////////////////////////

inline const LWNodeList::Node* LWNodeList::Node::Next() const
{
#if defined(RAD_OPT_DEBUG)
	AssertValid();
#endif
	return m_next;
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::Node::Prev()
//////////////////////////////////////////////////////////////////////////////////////////

inline LWNodeList::Node* LWNodeList::Node::Prev()
{
#if defined(RAD_OPT_DEBUG)
	AssertValid();
#endif
	return m_prev;
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::Node::Prev() const
//////////////////////////////////////////////////////////////////////////////////////////

inline const LWNodeList::Node* LWNodeList::Node::Prev() const
{
#if defined(RAD_OPT_DEBUG)
	AssertValid();
#endif
	return m_prev;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Sorting
//
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::InsertionSortInsert()
//////////////////////////////////////////////////////////////////////////////////////////

template< typename _COMPARE_PREDICATE >
void LWNodeList::InsertionSortInsert(Node* node, _COMPARE_PREDICATE& compare)
{
	const Node* sortLast = Last();
	typename _COMPARE_PREDICATE::Adapter0RetType compareValue = compare.arg0Adapter(const_cast<const Node*>(node));

	if (sortLast && (compare(compareValue, compare.arg1Adapter(sortLast)) < 0))
	{
		Node* before = First();

		while (true)
		{
			if (compare(compareValue, compare.arg1Adapter(before)) < 0)
			{
				InsertBefore(before, node);
				return;
			}

			before = before->Next();
		}
	}

	InsertLast(node);
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::InsertionSortResort()
//////////////////////////////////////////////////////////////////////////////////////////

template< typename _COMPARE_PREDICATE >
inline void LWNodeList::InsertionSortResort(Node* node, _COMPARE_PREDICATE& compare)
{
	Remove(node);
	InsertionSortInsert(node, compare);
}

//////////////////////////////////////////////////////////////////////////////////////////
// containter::LWNodeList::MergeSort()
//////////////////////////////////////////////////////////////////////////////////////////

template< typename _COMPARE_PREDICATE >
void LWNodeList::MergeSort(_COMPARE_PREDICATE& compare)
{
	Node* p;
	Node* q;
	Node* r;

	UReg			nInSize;
	UReg			nMerges;
	UReg			nSizeP;
	UReg			nSizeQ;
	UReg			i;

	nInSize = 1;

	while (true)
	{
	    p = m_head;

	    m_head = m_tail = NULL;
		m_size = 0;

	    nMerges = 0;  /* count number of merges we do in this pass */

	    while (p)
	    {
	        nMerges++;

	        q = p;

	        nSizeP = 0;

	        for (i = 0; i < nInSize; i++)
	        {
	            nSizeP++;

				q = q->Next();

	            if (!q)
	                break;
	        }


			/*	Merge the two lists.	*/

	        nSizeQ = nInSize;

	        while ((nSizeP > 0) || (nSizeQ > 0 && q != NULL))
	        {
	            if (nSizeP == 0)
	            {
					r = q;
					q = q->Next();

					nSizeQ--;
				}
				else if (nSizeQ == 0 || q == NULL)
				{
					r = p;
					p = p->Next();

					nSizeP--;
				}
				else
				{
					if (compare(compare.arg0Adapter(p), compare.arg1Adapter(q)) < 0)
					{
						r = p;
						p = p->Next();

						nSizeP--;
					}
					else
					{
						r = q;
						q = q->Next();

						nSizeQ--;
					}
				}


				/*	Put it on the list.	*/
#if defined(RAD_OPT_DEBUG)
				r->m_list = 0;
				r->m_next = r->m_prev = 0;
#endif
				InsertLast(r);
	        }

	        p = q;
	    }

		/*	Are we finished?	*/

	    if (nMerges > 1)
		{
			 nInSize = nInSize  << 1;
		}
		else
		{
			break;
		}
	}
}

} // container

