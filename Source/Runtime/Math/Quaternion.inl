// Quaternion.inl
// Copyright (c) 2010 Sunside Inc., All Rights Reserved
// Author: Mike Songy
// See Radiance/LICENSE for licensing terms.

namespace math {

//////////////////////////////////////////////////////////////////////////////////////////
// math::Lerp()
//////////////////////////////////////////////////////////////////////////////////////////

template <>
inline Quaternion<F32> Lerp<Quaternion<F32>, F32>(
	const Quaternion<F32> &start,
	const Quaternion<F32> &finish,
	const F32             &t
)
{
	return (start + (finish - start) * t).Unit();
}

template <>
inline Quaternion<F32> Lerp<Quaternion<F32>, F64>(
	const Quaternion<F32> &start,
	const Quaternion<F32> &finish,
	const F64            &t
)
{
	return Lerp(start, finish, F32(t));
}

template <>
inline Quaternion<F64> Lerp<Quaternion<F64>, F64>(
	const Quaternion<F64> &start,
	const Quaternion<F64> &finish,
	const F64             &t
)
{
	return (start + (finish - start) * t).Unit();
}

template <>
inline Quaternion<F64> Lerp<Quaternion<F64>, F32>(
	const Quaternion<F64> &start,
	const Quaternion<F64> &finish,
	const F32              &t
)
{
	return Lerp(start, finish, F64(t));
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Mid()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> QuaternionMid(const Quaternion<T> &p, const Quaternion<T> &q)
{
	T theta = ArcCos(p.m_v.Dot(q.m_v));
	if (theta != T(0.0)) { return ((p + q) * (Sin(theta * T(0.5)) / Sin(theta))); }
	else                 { return p; }
}

template <>
inline Quaternion<F32> Mid(const Quaternion<F32> &p, const Quaternion<F32> &q)
{
	return QuaternionMid<F32>(p, q);
}

template <>
inline Quaternion<F64> Mid(const Quaternion<F64> &p, const Quaternion<F64> &q)
{
	return QuaternionMid<F64>(p, q);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::operator*()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> operator*(T s, const Quaternion<T> &q)
{
	return Quaternion<T>(s * q.m_v);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Slerp()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> Slerp(const Quaternion<T> &p, const Quaternion<T> &q, T t)
{
	T theta = ArcCos(p.m_v.Dot(q.m_v));
	if (theta != T(0.0)) { return (p * Sin(theta * (T(1.0) - t)) + q * Sin(theta * t)) / Sin(theta); }
	else                 { return p; }
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::Identity
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
const Quaternion<T> Quaternion<T>::Identity = Quaternion<T>(T(0.0), T(0.0), T(0.0), T(1.0));

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::Quaternion()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T>::Quaternion()
{
}

template <typename T>
inline Quaternion<T>::Quaternion(const T *v) :
m_v(v)
{
}

template <typename T>
inline Quaternion<T>::Quaternion(T x, T y, T z, T w) :
m_v(x, y, z, w)
{
}

template <typename T>
inline Quaternion<T>::Quaternion(const Vector4<T> &v) :
m_v(v)
{
}

template <typename T>
inline Quaternion<T>::Quaternion(const Vector3<T> &v, const T &rad)
{
	Initialize(v, rad);	
}

template <typename T>
inline Quaternion<T>::Quaternion(const Quaternion<T> &q) :
m_v(q.m_v)
{
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::~Quaternion()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T>::~Quaternion()
{
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::ToAxisAngle()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
AxisAngle<T> Quaternion<T>::ToAxisAngle(const T &epsilon) const
{
	Quaternion<T> q(Unit());
	T sinAngle = SquareRoot(T(1.0) - Square(q.W()));
	if (NearlyZero(sinAngle, epsilon)) { sinAngle = T(1.0); }
	return AxisAngle<T>(
		Vector3<T>(q.X(), q.Y(), q.Z()) / sinAngle,
		ArcCos(q.W()) * T(2.0)
	);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::operator[]()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline const T &Quaternion<T>::operator[](int i) const
{
	return m_v[i];
}

template <typename T>
inline T &Quaternion<T>::operator[](int i)
{
	return m_v[i];
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::X
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline T Quaternion<T>::X() const
{
	return m_v.X();
}

template <typename T>
inline void Quaternion<T>::SetX(T x)
{
	m_v.SetX(x);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::Y
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline T Quaternion<T>::Y() const
{
	return m_v.Y();
}

template <typename T>
inline void Quaternion<T>::SetY(T y)
{
	m_v.SetY(y);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::Z
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline T Quaternion<T>::Z() const
{
	return m_v.Z();
}

template <typename T>
inline void Quaternion<T>::SetZ(T z)
{
	m_v.SetZ(z);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::W
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline T Quaternion<T>::W() const
{
	return m_v.W();
}

template <typename T>
inline void Quaternion<T>::SetW(T w)
{
	m_v.SetW(w);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::Initialize()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> &Quaternion<T>::Initialize(const T *v)
{
	m_v.Initialize(v);
	return *this;
}

template <typename T>
inline Quaternion<T> &Quaternion<T>::Initialize(T x, T y, T z, T w)
{
	m_v.Initialize(x, y, z, w);
	return *this;
}

template <typename T>
inline Quaternion<T> &Quaternion<T>::Initialize(const Vector4<T> &v)
{
	m_v = v;
}

template <typename T>
inline Quaternion<T> &Quaternion<T>::Initialize(const Vector3<T> &v, const T &rad)
{
	T sin, w;
	SinAndCos(&sin, &w, rad / T(2.0));
	m_v.Initialize(v * sin, w);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::MakeIdentity()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> &Quaternion<T>::MakeIdentity()
{
	return operator=(Identity);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::MakeConjugate()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> &Quaternion<T>::MakeConjugate()
{
	m_v.Vector3<T>::Reverse();
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::Normalize()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> &Quaternion<T>::Normalize()
{
	m_v.Normalize();
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::Reverse()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> &Quaternion<T>::Reverse()
{
	m_v.Reverse();
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::Invert()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> &Quaternion<T>::Invert()
{
	MakeConjugate();
	Normalize();
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::operator-()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> Quaternion<T>::operator-() const
{
	return Quaternion<T>(-m_v);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::Magnitude()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline T Quaternion<T>::Magnitude() const
{
	return m_v.Magnitude();
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::MagnitudeSquared()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline T Quaternion<T>::MagnitudeSquared() const
{
	return m_v.MagnitudeSquared();
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::Conjugate()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> Quaternion<T>::Conjugate() const
{
	return Quaternion<T>(Vector4<T>(m_v.Vector3<T>::operator-(), m_v.W()));
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::Unit()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> Quaternion<T>::Unit() const
{
	return Quaternion<T>(m_v.Unit());
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::Inverse()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> Quaternion<T>::Inverse() const
{
	return Conjugate().Unit();
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::operator+()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> Quaternion<T>::operator+(const Quaternion<T> &q) const
{
	return Quaternion<T>(m_v + q.m_v);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::operator-()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> Quaternion<T>::operator-(const Quaternion<T> &q) const
{
	return Quaternion<T>(m_v - q.m_v);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::operator*()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> Quaternion<T>::operator*(const Quaternion<T> &q) const
{
	return Quaternion<T>(
		m_v.Y() * q.m_v.Z() - m_v.Z() * q.m_v.Y() + m_v.W() * q.m_v.X() + m_v.X() * q.m_v.W(),
		m_v.Z() * q.m_v.X() - m_v.X() * q.m_v.Z() + m_v.W() * q.m_v.Y() + m_v.Y() * q.m_v.W(),
		m_v.X() * q.m_v.Y() - m_v.Y() * q.m_v.X() + m_v.W() * q.m_v.Z() + m_v.Z() * q.m_v.W(),
		m_v.W() * q.m_v.W() - m_v.X() * q.m_v.X() - m_v.Y() * q.m_v.Y() - m_v.Z() * q.m_v.Z()
	);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::operator=()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> &Quaternion<T>::operator=(const Quaternion<T> &q)
{
	m_v = q.m_v;
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::operator+=()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> &Quaternion<T>::operator+=(const Quaternion<T> &q)
{
	m_v += q.m_v;
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::operator-=()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> &Quaternion<T>::operator-=(const Quaternion<T> &q)
{
	m_v -= q.m_v;
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::operator*=()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> &Quaternion<T>::operator*=(const Quaternion<T> &q)
{
	return Initialize(*this * q);			
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::operator*()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> Quaternion<T>::operator*(T s) const
{
	return Quaternion<T>(m_v * s);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::operator/()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> Quaternion<T>::operator/(T s) const
{
	return Quaternion<T>(m_v / s);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::operator*=()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> &Quaternion<T>::operator*=(T s)
{
	m_v *= s;
	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Quaternion<T>::operator*=()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Quaternion<T> &Quaternion<T>::operator/=(T s)
{
	m_v /= s;
	return *this;
}

template <typename T>
bool Quaternion<T>::operator==(const Quaternion<T> &v) const
{
	return m_v == v.m_v;
}

template <typename T>
bool Quaternion<T>::operator!=(const Quaternion<T> &v) const
{
	return m_v != v.m_v;
}

} // math

