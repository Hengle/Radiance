// Rect.inl
// Copyright (c) 2010 Sunside Inc., All Rights Reserved
// Author: Mike Songy
// See Radiance/LICENSE for licensing terms.

namespace math {

//////////////////////////////////////////////////////////////////////////////////////////
// math::Intersection()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
Rect<T> Intersection(const Rect<T> &a, const Rect<T> &b, typename Rect<T>::Hint hint)
{
	RAD_ASSERT(hint == Rect<T>::NOT_DEGENERATE);
	RAD_ASSERT(!a.IsDegenerate());
	RAD_ASSERT(!b.IsDegenerate());

	return Rect<T>(
		Max(a.m_mins.X(), b.m_mins.X()),
		Max(a.m_mins.Y(), b.m_mins.Y()),
		Min(a.m_maxs.X(), b.m_maxs.X()),
		Min(a.m_maxs.Y(), b.m_maxs.Y())
	);
}

template <typename T>
Rect<T> Intersection(const Rect<T> &a, const Rect<T> &b)
{
	if (a.IsDegenerate() || b.IsDegenerate())
	{
		return Rect<T>(T(0.0), T(0.0), T(0.0), T(0.0)); 
	}
	else
	{
		return Intersection(a, b, Rect<T>::NOT_DEGENERATE); 
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Union()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
Rect<T> Union(const Rect<T> &a, const Rect<T> &b, typename Rect<T>::Hint hint)
{
	RAD_ASSERT(hint == Rect<T>::NOT_DEGENERATE);
	RAD_ASSERT(!a.IsDegenerate());
	RAD_ASSERT(!b.IsDegenerate());

	return Rect<T>(
		Min(a.m_mins.X(), b.m_mins.X()),
		Min(a.m_mins.Y(), b.m_mins.Y()),
		Max(a.m_maxs.X(), b.m_maxs.X()),
		Max(a.m_maxs.Y(), b.m_maxs.Y())
	);
}

template <typename T>
Rect<T> Union(const Rect<T> &a, const Rect<T> &b)
{
	if (a.IsDegenerate() || b.IsDegenerate())
	{
		return Rect<T>(T(0.0), T(0.0), T(0.0), T(0.0));
	}
	else
	{
		return Union(a, b, Rect<T>::NOT_DEGENERATE);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Rect()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Rect<T>::Rect()
: m_mins()
, m_maxs()
{
}

template <typename T>
inline Rect<T>::Rect(T left, T top, T right, T bottom)
: m_mins(left, top)
, m_maxs(right, bottom)
{
}

template <typename T>
inline Rect<T>::Rect(const Vector2<T> &mins, const Vector2<T> &maxs)
: m_mins(mins)
, m_maxs(maxs)
{
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::~Rect()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Rect<T>::~Rect()
{
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Initialize()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline void Rect<T>::Initialize(T left, T top, T right, T bottom)
{
	m_mins.Initialize(left, top);
	m_maxs.Initialize(right, bottom);
}

template <typename T>
inline void Rect<T>::Initialize(const Vector2<T> &mins, const Vector2<T> &maxs)
{
	m_mins = mins;
	m_maxs = maxs;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::SetMins()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline void Rect<T>::SetMins(const Vector2<T> &mins)
{
	m_mins = mins;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::SetMaxs()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline void Rect<T>::SetMaxs(const Vector2<T> &maxs)
{
	m_maxs = maxs;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Expand()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline void Rect<T>::Expand(const Vector2<T> &exp)
{
	T w = exp.X() / 2.0f;
	T h = exp.Y() / 2.0f;
	m_mins.Initialize(m_mins.X()-w, m_mins.Y()-h);
	m_maxs.Initialize(m_maxs.X()+w, m_maxs.Y()+h);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::SetLeft()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline void Rect<T>::SetLeft(T left)
{
	m_mins.SetX(left);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::SetTop()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline void Rect<T>::SetTop(T top)
{
	m_mins.SetY(top);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::SetRight()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline void Rect<T>::SetRight(T right)
{
	m_maxs.SetX(right);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::SetBottom()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline void Rect<T>::SetBottom(T bottom)
{
	m_maxs.SetY(bottom);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Mins()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline const Vector2<T> &Rect<T>::Mins() const
{
	return m_mins;
}

template <typename T>
inline Vector2<T> &Rect<T>::Mins()
{
	return m_mins;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Maxs()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline const Vector2<T> &Rect<T>::Maxs() const
{
	return m_maxs;
}

template <typename T>
inline Vector2<T> &Rect<T>::Maxs()
{
	return m_maxs;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Center()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Vector2<T> Rect<T>::Center() const
{
	return (m_maxs + m_mins) / T(2);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Extents()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Vector2<T> Rect<T>::Extents() const
{
	return m_maxs - m_mins;
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Left()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline T Rect<T>::Left() const
{
	return m_mins.X();
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Top()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline T Rect<T>::Top() const
{
	return m_mins.Y();
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Right()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline T Rect<T>::Right() const
{
	return m_maxs.X();
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Bottom()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline T Rect<T>::Bottom() const
{
	return m_maxs.Y();
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Width()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline T Rect<T>::Width() const
{
	return Max(m_maxs.X() - m_mins.X(), T(0.0)); 
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Height()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline T Rect<T>::Height() const
{
	return Max(m_maxs.Y() - m_mins.Y(), T(0.0));
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::IsDegenerate()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline bool Rect<T>::IsDegenerate() const
{
	return (m_maxs.X() <= m_mins.X() || m_maxs.Y() <= m_mins.Y());
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::ContainsX()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline bool Rect<T>::ContainsX(T x) const
{
	return (x >= m_mins.X() && x <  m_maxs.X());
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::ContainsY()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline bool Rect<T>::ContainsY(T y) const
{
	return (y >= m_mins.Y() && y <  m_maxs.Y());
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Contains()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline bool Rect<T>::Contains(const Vector2<T> &point) const
{
	return (ContainsX(point.X()) && ContainsY(point.Y()));
}

template <typename T>
bool Rect<T>::Contains(const Rect<T> &rect) const
{
	RAD_ASSERT(!rect.IsDegenerate());

	return (Contains(rect.m_mins) && Contains(rect.m_maxs));
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Contains()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
bool Rect<T>::Intersects(const Rect<T> &rect, Hint hint) const
{
	RAD_ASSERT(hint == NOT_DEGENERATE);
	RAD_ASSERT(!IsDegenerate());
	RAD_ASSERT(!rect.IsDegenerate());

	if (rect.m_mins.X() > m_maxs.X() || rect.m_mins.Y() > m_maxs.Y())
	{
		return false;
	}

	if (m_mins.X() > rect.m_maxs.X() || m_mins.Y() > rect.m_maxs.Y())
	{
		return false;
	}

	return true;
}

template <typename T>
bool Rect<T>::Intersects(const Rect<T> &rect) const
{
	if (IsDegenerate() || rect.IsDegenerate())
	{
		return false;
	}
	else
	{
		return Intersects(rect, NOT_DEGENERATE); 
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::Area()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline T Rect<T>::Area() const
{
	return (Width() * Height());
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::operator &()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Rect<T> Rect<T>::operator &(const Rect<T> &other) const
{
	return Intersection(*this, other);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::operator |()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline Rect<T> Rect<T>::operator |(const Rect<T> &other) const
{
	return Union(*this, other);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::operator ==()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline bool Rect<T>::operator ==(const Rect<T> &other) const
{
	return (m_mins == other.m_mins && m_maxs == other.m_maxs);
}

//////////////////////////////////////////////////////////////////////////////////////////
// math::Rect<T>::operator !=()
//////////////////////////////////////////////////////////////////////////////////////////

template <typename T>
inline bool Rect<T>::operator !=(const Rect<T> &other) const
{
	return (m_mins != other.m_mins || m_maxs != other.m_maxs);
}

} // math

