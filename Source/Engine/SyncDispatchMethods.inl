// SyncDispatchMethods.inl
// Copyright (c) 2010 Sunside Inc., All Rights Reserved
// auto generated by Radiance/Source/sync_dispatch.py
// See Radiance/LICENSE for licensing terms.

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17, const A18 &a18, const A19 &a19, const A20 &a20, const A21 &a21)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20, typename A21>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17, const A18 &a18, const A19 &a19, const A20 &a20, const A21 &a21)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17, const A18 &a18, const A19 &a19, const A20 &a20)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17, const A18 &a18, const A19 &a19, const A20 &a20)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17, const A18 &a18, const A19 &a19)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17, const A18 &a18, const A19 &a19)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17, const A18 &a18)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17, const A18 &a18)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7, a8, a9);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7, a8);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7, a8);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7, a8);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6, a7);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6, a7);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6, a7);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5, a6);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5, a6);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5, a6);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4, a5);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4, A5> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4, a5);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4, a5);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3, a4);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3, A4> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3, a4);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3, a4);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3)
{
	if (!control)
	{
		(obj->*fn)(a1, a2, a3);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2, A3> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2, a3);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2, typename A3>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2, a3);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1, const A2 &a2)
{
	if (!control)
	{
		(obj->*fn)(a1, a2);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1, A2> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1, a2);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1, typename A2>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1, const A2 &a2)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1, a2);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn, const A1 &a1)
{
	if (!control)
	{
		(obj->*fn)(a1);
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F, A1> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn, a1);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F, typename A1>
void DispatchClassMethod(const task::HControl &control, C obj, F fn, const A1 &a1)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn, a1);
	if (control && list.size > 0)
		control->Wait(list);
}

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F>
void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn)
{
	if (!control)
	{
		(obj->*fn)();
		return;
	}
	typedef sync_dispatch::ClassMethodFunctor<C, F> M;
	M *m = new (M::pool_type::allocate(1)) M(obj, fn);
	RAD_OUT_OF_MEM(m);
	task::HGate gate = control->CreateGate(false, false);
	sync_dispatch::QueueCallback(m, gate);
	list.PushBack(gate);
}

template <typename C, typename F>
void DispatchClassMethod(const task::HControl &control, C obj, F fn)
{
	task::FixedGateList<1> list;
	QueueClassMethod(control, list, obj, fn);
	if (control && list.size > 0)
		control->Wait(list);
}

