// PackageFunctor.h
// Copyright (c) 2010 Pyramind Labs LLC, All Rights Reserved
// auto generated by Radiance/Source/package_functor.py
// See Radiance/LICENSE for licensing terms.

#include <boost/pool/pool_alloc.hpp>
#include <Runtime/PushPack.h>

namespace pkg {
namespace details {

class RADENG_CLASS IFunctorBase
{
public:
	virtual void Call() = 0;
	virtual void Release() = 0;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1 = void, typename A2 = void, typename A3 = void, typename A4 = void, typename A5 = void, typename A6 = void, typename A7 = void, typename A8 = void, typename A9 = void, typename A10 = void, typename A11 = void, typename A12 = void, typename A13 = void, typename A14 = void, typename A15 = void, typename A16 = void, typename A17 = void, typename A18 = void, typename A19 = void, typename A20 = void, typename A21 = void>
class ClassMethodFunctor : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17, const A18 &a18, const A19 &a19, const A20 &a20, const A21 &a21) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		, m_a8(a8)
		, m_a9(a9)
		, m_a10(a10)
		, m_a11(a11)
		, m_a12(a12)
		, m_a13(a13)
		, m_a14(a14)
		, m_a15(a15)
		, m_a16(a16)
		, m_a17(a17)
		, m_a18(a18)
		, m_a19(a19)
		, m_a20(a20)
		, m_a21(a21)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7, m_a8, m_a9, m_a10, m_a11, m_a12, m_a13, m_a14, m_a15, m_a16, m_a17, m_a18, m_a19, m_a20, m_a21);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
	A8 m_a8;
	A9 m_a9;
	A10 m_a10;
	A11 m_a11;
	A12 m_a12;
	A13 m_a13;
	A14 m_a14;
	A15 m_a15;
	A16 m_a16;
	A17 m_a17;
	A18 m_a18;
	A19 m_a19;
	A20 m_a20;
	A21 m_a21;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19, typename A20>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17, const A18 &a18, const A19 &a19, const A20 &a20) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		, m_a8(a8)
		, m_a9(a9)
		, m_a10(a10)
		, m_a11(a11)
		, m_a12(a12)
		, m_a13(a13)
		, m_a14(a14)
		, m_a15(a15)
		, m_a16(a16)
		, m_a17(a17)
		, m_a18(a18)
		, m_a19(a19)
		, m_a20(a20)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7, m_a8, m_a9, m_a10, m_a11, m_a12, m_a13, m_a14, m_a15, m_a16, m_a17, m_a18, m_a19, m_a20);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
	A8 m_a8;
	A9 m_a9;
	A10 m_a10;
	A11 m_a11;
	A12 m_a12;
	A13 m_a13;
	A14 m_a14;
	A15 m_a15;
	A16 m_a16;
	A17 m_a17;
	A18 m_a18;
	A19 m_a19;
	A20 m_a20;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18, typename A19>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17, const A18 &a18, const A19 &a19) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		, m_a8(a8)
		, m_a9(a9)
		, m_a10(a10)
		, m_a11(a11)
		, m_a12(a12)
		, m_a13(a13)
		, m_a14(a14)
		, m_a15(a15)
		, m_a16(a16)
		, m_a17(a17)
		, m_a18(a18)
		, m_a19(a19)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7, m_a8, m_a9, m_a10, m_a11, m_a12, m_a13, m_a14, m_a15, m_a16, m_a17, m_a18, m_a19);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
	A8 m_a8;
	A9 m_a9;
	A10 m_a10;
	A11 m_a11;
	A12 m_a12;
	A13 m_a13;
	A14 m_a14;
	A15 m_a15;
	A16 m_a16;
	A17 m_a17;
	A18 m_a18;
	A19 m_a19;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17, typename A18>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17, const A18 &a18) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		, m_a8(a8)
		, m_a9(a9)
		, m_a10(a10)
		, m_a11(a11)
		, m_a12(a12)
		, m_a13(a13)
		, m_a14(a14)
		, m_a15(a15)
		, m_a16(a16)
		, m_a17(a17)
		, m_a18(a18)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7, m_a8, m_a9, m_a10, m_a11, m_a12, m_a13, m_a14, m_a15, m_a16, m_a17, m_a18);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
	A8 m_a8;
	A9 m_a9;
	A10 m_a10;
	A11 m_a11;
	A12 m_a12;
	A13 m_a13;
	A14 m_a14;
	A15 m_a15;
	A16 m_a16;
	A17 m_a17;
	A18 m_a18;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16, typename A17>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16, const A17 &a17) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		, m_a8(a8)
		, m_a9(a9)
		, m_a10(a10)
		, m_a11(a11)
		, m_a12(a12)
		, m_a13(a13)
		, m_a14(a14)
		, m_a15(a15)
		, m_a16(a16)
		, m_a17(a17)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7, m_a8, m_a9, m_a10, m_a11, m_a12, m_a13, m_a14, m_a15, m_a16, m_a17);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
	A8 m_a8;
	A9 m_a9;
	A10 m_a10;
	A11 m_a11;
	A12 m_a12;
	A13 m_a13;
	A14 m_a14;
	A15 m_a15;
	A16 m_a16;
	A17 m_a17;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15, typename A16>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15, const A16 &a16) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		, m_a8(a8)
		, m_a9(a9)
		, m_a10(a10)
		, m_a11(a11)
		, m_a12(a12)
		, m_a13(a13)
		, m_a14(a14)
		, m_a15(a15)
		, m_a16(a16)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7, m_a8, m_a9, m_a10, m_a11, m_a12, m_a13, m_a14, m_a15, m_a16);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
	A8 m_a8;
	A9 m_a9;
	A10 m_a10;
	A11 m_a11;
	A12 m_a12;
	A13 m_a13;
	A14 m_a14;
	A15 m_a15;
	A16 m_a16;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14, typename A15>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14, const A15 &a15) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		, m_a8(a8)
		, m_a9(a9)
		, m_a10(a10)
		, m_a11(a11)
		, m_a12(a12)
		, m_a13(a13)
		, m_a14(a14)
		, m_a15(a15)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7, m_a8, m_a9, m_a10, m_a11, m_a12, m_a13, m_a14, m_a15);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
	A8 m_a8;
	A9 m_a9;
	A10 m_a10;
	A11 m_a11;
	A12 m_a12;
	A13 m_a13;
	A14 m_a14;
	A15 m_a15;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13, typename A14>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13, const A14 &a14) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		, m_a8(a8)
		, m_a9(a9)
		, m_a10(a10)
		, m_a11(a11)
		, m_a12(a12)
		, m_a13(a13)
		, m_a14(a14)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7, m_a8, m_a9, m_a10, m_a11, m_a12, m_a13, m_a14);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
	A8 m_a8;
	A9 m_a9;
	A10 m_a10;
	A11 m_a11;
	A12 m_a12;
	A13 m_a13;
	A14 m_a14;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12, typename A13>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12, const A13 &a13) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		, m_a8(a8)
		, m_a9(a9)
		, m_a10(a10)
		, m_a11(a11)
		, m_a12(a12)
		, m_a13(a13)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7, m_a8, m_a9, m_a10, m_a11, m_a12, m_a13);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
	A8 m_a8;
	A9 m_a9;
	A10 m_a10;
	A11 m_a11;
	A12 m_a12;
	A13 m_a13;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11, typename A12>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11, const A12 &a12) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		, m_a8(a8)
		, m_a9(a9)
		, m_a10(a10)
		, m_a11(a11)
		, m_a12(a12)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7, m_a8, m_a9, m_a10, m_a11, m_a12);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
	A8 m_a8;
	A9 m_a9;
	A10 m_a10;
	A11 m_a11;
	A12 m_a12;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10, typename A11>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10, const A11 &a11) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		, m_a8(a8)
		, m_a9(a9)
		, m_a10(a10)
		, m_a11(a11)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7, m_a8, m_a9, m_a10, m_a11);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
	A8 m_a8;
	A9 m_a9;
	A10 m_a10;
	A11 m_a11;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9, typename A10>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9, const A10 &a10) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		, m_a8(a8)
		, m_a9(a9)
		, m_a10(a10)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7, m_a8, m_a9, m_a10);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
	A8 m_a8;
	A9 m_a9;
	A10 m_a10;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8, A9> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		, m_a8(a8)
		, m_a9(a9)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7, m_a8, m_a9);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
	A8 m_a8;
	A9 m_a9;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7, A8> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		, m_a8(a8)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7, m_a8);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
	A8 m_a8;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6, A7> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		, m_a7(a7)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6, m_a7);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
	A7 m_a7;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5, A6> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		, m_a6(a6)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5, m_a6);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
	A6 m_a6;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4, typename A5>
class ClassMethodFunctor<C, F, A1, A2, A3, A4, A5> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4, A5> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		, m_a5(a5)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4, m_a5);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
	A5 m_a5;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3, typename A4>
class ClassMethodFunctor<C, F, A1, A2, A3, A4> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3, A4> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		, m_a4(a4)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3, m_a4);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
	A4 m_a4;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2, typename A3>
class ClassMethodFunctor<C, F, A1, A2, A3> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2, A3> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2, const A3 &a3) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		, m_a3(a3)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2, m_a3);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
	A3 m_a3;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1, typename A2>
class ClassMethodFunctor<C, F, A1, A2> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1, A2> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1, const A2 &a2) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		, m_a2(a2)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1, m_a2);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
	A2 m_a2;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F, typename A1>
class ClassMethodFunctor<C, F, A1> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F, A1> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn, const A1 &a1) : m_obj(obj), m_fn(fn)
		, m_a1(a1)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)(m_a1);
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
	A1 m_a1;
};

//////////////////////////////////////////////////////////////////////////////////////////

template <typename C, typename F>
class ClassMethodFunctor<C, F> : public IFunctorBase
{
public:

	typedef ClassMethodFunctor<C, F> Type;
	typedef boost::pool_allocator<Type> pool_type;

	ClassMethodFunctor(C obj, F fn) : m_obj(obj), m_fn(fn)
		{}

	virtual void Call()
	{
		(m_obj->*m_fn)();
	}

	virtual void Release()
	{
		pool_type::destroy(this);
		pool_type::deallocate(pool_type::address(*this), 1);
	}

private:

	C m_obj;
	F m_fn;
};

} // details
} // pkg

#include <Runtime/PopPack.h>

