# package_functor.py
# Copyright (c) 2010 Sunside Inc., All Rights Reserved
# Author: Joe Riedel
# See Radiance/LICENSE for licensing terms.
# Generates Engine/Packages/PackageFunctor.inl file

import io
import template_args as z

print "generating Engine/SyncDispatchFunctor.inl..."

s = io.open('Engine/SyncDispatchFunctor.inl', 'w')
s.write(u'// SyncDispatch.h\n')
s.write(u'// Copyright (c) 2010 Sunside Inc., All Rights Reserved\n')
s.write(u'// auto generated by Radiance/Source/sync_dispatch.py\n')
s.write(u'// See Radiance/LICENSE for licensing terms.\n\n')

s.write(u'#include <boost/pool/pool_alloc.hpp>\n')
s.write(u'#include <Runtime/PushPack.h>\n\n')

s.write(u'namespace sync_dispatch {\n\n')

s.write(u'class RADENG_CLASS IFunctorBase\n{\npublic:\n')
s.write(u'\tvirtual void Call() = 0;\n')
s.write(u'\tvirtual void Release() = 0;\n')
s.write(u'};\n\n')

def genClassMethod(s, n, void):
	s.write(u'//////////////////////////////////////////////////////////////////////////////////////////\n\n')
	s.write(u'template <typename C, typename F')
	for x in range(1, n):
		if void:
			s.write(u', typename A%d = void' % x)
		else:
			s.write(u', typename A%d' % x)
	s.write(u'>\n')
	s.write(u'class ClassMethodFunctor')
	if not void:
		s.write(u'<C, F')
		for x in range(1, n):
			s.write(u', A%d' % x)
		s.write(u'>')
	s.write(u' : public IFunctorBase\n{\npublic:\n\n')
	s.write(u'\ttypedef ClassMethodFunctor<C, F')
	for x in range(1, n):
		s.write(u', A%d' % x)
	s.write(u'> Type;\n')
	s.write(u'\ttypedef boost::pool_allocator<Type> pool_type;\n\n')
	s.write(u'\tClassMethodFunctor(C obj, F fn')
	for x in range(1, n):
		s.write(u', const A%d &a%d' % (x, x))
	s.write(u') : m_obj(obj), m_fn(fn)\n')
	for x in range(1, n):
		s.write(u'\t\t, m_a%d(a%d)\n' % (x, x))
	s.write(u'\t\t{}\n\n')
	s.write(u'\tvirtual void Call()\n\t{\n')
	s.write(u'\t\t(m_obj->*m_fn)(')
	for x in range(1, n):
		if x > 1:
			s.write(u', m_a%d' % x)
		else:
			s.write(u'm_a%d' % x)
	s.write(u');\n\t}\n\n')
	s.write(u'\tvirtual void Release()\n\t{\n')
	s.write(u'\t\tpool_type::destroy(this);\n\t\tpool_type::deallocate(pool_type::address(*this), 1);\n')
	s.write(u'\t}\n\n')
	s.write(u'private:\n\n\tC m_obj;\n\tF m_fn;\n')
	for x in range(1, n):
		s.write(u'\tA%d m_a%d;\n' % (x, x));
	s.write(u'};\n\n')
	
for x in range(22, 0, -1):
	genClassMethod(s, x, x == 22)

s.write(u'} // sync_dispatch\n\n')
s.write(u'#include <Runtime/PopPack.h>\n\n')
s.close()

print "generating Engine/SyncDispatchMethods.inl..."

s = io.open('Engine/SyncDispatchMethods.inl', 'w')
s.write(u'// SyncDispatchMethods.inl\n')
s.write(u'// Copyright (c) 2010 Sunside Inc., All Rights Reserved\n')
s.write(u'// auto generated by Radiance/Source/sync_dispatch.py\n')
s.write(u'// See Radiance/LICENSE for licensing terms.\n\n')

def genSinkMethods(s, n):
	s.write(u'//////////////////////////////////////////////////////////////////////////////////////////\n\n')
	s.write(u'template <typename C, typename F')
	for x in range(1, n):
		s.write(u', typename A%d' % x)
	s.write(u'>\n')
	s.write(u'void QueueClassMethod(const task::HControl &control, task::IGateList &list, C obj, F fn')
	for x in range(1, n):
		s.write(u', const A%d &a%d' % (x, x))
	s.write(u')\n{\n')
	s.write(u'\tif (!control)\n\t{\n')
	s.write(u'\t\t(obj->*fn)(')
	for x in range(1, n):
		if x > 1:
			s.write(u', a%d' % x)
		else:
			s.write(u'a1')
	s.write(u');\n\t\treturn;\n\t}\n')
	s.write(u'\ttypedef sync_dispatch::ClassMethodFunctor<C, F')
	for x in range(1, n):
		s.write(u', A%d' % x)
	s.write(u'> M;\n')
	s.write(u'\tM *m = new (M::pool_type::allocate(1)) M(obj, fn')
	for x in range(1, n):
		s.write(u', a%d' % x)
	s.write(u');\n')
	s.write(u'\tRAD_OUT_OF_MEM(m);\n')
	s.write(u'\ttask::HGate gate = control->CreateGate(false, false);\n')
	s.write(u'\tsync_dispatch::QueueCallback(m, gate);\n')
	s.write(u'\tlist.PushBack(gate);\n')
	s.write(u'}\n\n')
	
	s.write(u'template <typename C, typename F')
	for x in range(1, n):
		s.write(u', typename A%d' % x)
	s.write(u'>\n')
	s.write(u'void DispatchClassMethod(const task::HControl &control, C obj, F fn')
	for x in range(1, n):
		s.write(u', const A%d &a%d' % (x, x))
	s.write(u')\n{\n')
	s.write(u'\ttask::FixedGateList<1> list;\n')
	s.write(u'\tQueueClassMethod(control, list, obj, fn')
	for x in range(1, n):
		s.write(u', a%d' % x)
	s.write(u');\n')
	s.write(u'\tif (control && list.size > 0)\n\t\tcontrol->Wait(list);\n')
	s.write(u'}\n\n')

for x in range(22, 0, -1):
	genSinkMethods(s, x)

s.close()
